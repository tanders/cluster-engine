==================
Function Reference
==================

    :Author: torsten



Solver Call
-----------

The following functions are part of virtually all programs using the Cluster Engine library.

.. _CLUSTERENGINE:

  .. index::
     single: CLUSTERENGINE (function)

 *function* (**CLUSTERENGINE** NO-OF-VARIABLES RND? DEBUG? RULES METRIC-DOMAIN LIST-OF-DOMAINS)
    The Cluster Engine - the main function of this library. 

    Pitch domains cannot exist without at least one duration in the rhythm domain. Domains with only one value will not use up any time in the search process.

    See the PWGL tutorials of this library for a detailed discussion of this function.



.. _RULES->CLUSTER:

  .. index::
     single: RULES->CLUSTER (function)

 *function* (**RULES->CLUSTER** &REST RULES)
    Use this box to collect all rules before inputting them to the box/function `clusterengine`_. It is possible to input the output of this box to a second Rules->Cluster box (to help organizing your rules in groups).


Test: see also function `CLUSTERENGINE`_ 

Rule Definitions
----------------

This section documents functions by which users can define their own musical rules. Their results (one or more functions) are typically given to the function `RULES->CLUSTER`_ . 

Rules for One "Engine"
~~~~~~~~~~~~~~~~~~~~~~

Functions for defining rules that restrict only one domain in one voice (e.g., only the pitches of the first voice). 


  .. _R-RHYTHMS-ONE-VOICE:

    .. index::
       single: R-RHYTHMS-ONE-VOICE (function)

 *function* (**R-RHYTHMS-ONE-VOICE** RULE VOICES INPUT-MODE &OPTIONAL RULE-TYPE WEIGHT)
    :RULE: is a logic statement in he form of a function. The output of the function has to be either true or false. If there are more than one input to the function, they will receive consecutive durations (or consecutive motifs depending on the input-mode). 

    :VOICES: is the number for the voice (starting at 0) that the rule affects. It is possible to give a list of several voice numbers: The rule will then be applied to every voice in the list (independant of each other).

    :INPUT-MODE: determines what type of variables the rule will receive in its inputs:

    - ``:durations`` The rule will receive individual durations, one for each input.

    - ``:dur/time`` As above, but the start-time of the duration will be indicated.
      Format: '(duration start-time), Ex. '(1/4 9/4)

    - ``:motifs`` The rule will receive motifs, one (consecutive) motif for each 
      input. A motif is a collection of durations that are grouped in 
      a list. Motifs are designed in the domain and cannot be 
      redesignedby the engine. Note that a motif may be a single 
      duration (a list with one duration-ratio) if it is defined as 
      such in the domain.

    - ``:motif/time`` As the previous selection, but with the start-time of the first event in the motif added. Format: '(motif start-time)
      Ex. '((1/4 -1/8) 9/8)

    - ``:all-durations`` All durations in the voice that are assigned at the time the rule is checked are given as a list of duration ratios. The list will thus become longer and longer during the search. The rule can only have ONE input in this mode.

    **Optional inputs**

    By expanding the box it is possible to use the rule as a heuristic switch rule. A heuristic switch rule is still using a logic statement (that outputs true or false), but the effect of the rule is different: If the rule is true, the weight (given in the <weight> input) is passed to the engine. If it is false, a weight of 0 will be passed. A candidate that receive a high weight will have a higher priority for being picked when the true/false rules are checked. A heuristic rule can never fail a candidate, nor can it trigger backtracking of the engine. Heuristic rules only sort the candidates locally before the strict rules are applied. Depending on the context, heuristic rules might have more or less of an effect. 

    Heuristic switch rules differs slightly form regular heuristic rules (the latter don't output true or false, but a weight that might vary dependingon the candidate).

    [Backtracking: This rule will trigger backtracking in its own engine.]



  .. _R-INDEX-RHYTHMS-ONE-VOICE:

    .. index::
       single: R-INDEX-RHYTHMS-ONE-VOICE (function)

 *function* (**R-INDEX-RHYTHMS-ONE-VOICE** RULE POSITIONS VOICES INPUT-MODE &OPTIONAL RULE-TYPE WEIGHT)
    <rule> is a logic statement in he form of a function. The output of the 
    function has to be either true or false. The function should have as many 
    inputs as there are positions given in the <positions> list.

    <positions> is a list of positions where the logic statement is applied.
    Positions are counted from 0. Every position in this list corresponds to
    an input in the rule. See also input-mode below.

    <voices> is the number for the voice (starting at 0) that the rule affects. 
    It is possible to give a list of several voice numbers: The rule will then 
    be applied to every voice in the list (independant of each other).

    <input-mode> determines what type of variables the rule will receive in 
    its inputs:

    - index-for-cell: The rule will receive motifs as lists of duration 
      ratios. The positions given above refer to the index
      number for the motifs in the solution. Each input 
      will receive one corresponding motif.

    - position-for-duration: The rule will receive individual
      durations, one for each given position.
      The positions refer to the position
      of the individual duraions in the solution.
      Rests are included.

    [Backtracking: This rule will trigger backtracking in its own engine.]


Optional inputs:
By expanding the box it is possible to use the rule as a heuristic switch 
rule. A heuristic switch rule is still using a logic statement (that 
outputs true or false), but the effect of the rule is different: If the rule 
is true, the weight (given in the <weight> input) is passed to the engine. 
If it is false, a weight of 0 will be passed. A candidate that receive a 
high weight will have a higher priority for being picked when the true/false 
rules are checked. A heuristic rule can never fail a candidate, nor can it 
trigger backtracking of the engine. Heuristic rules only sort the 
candidates locally before the strict rules are applied. Depending on the 
context, heuristic rules might have more or less of an effect. 

Heuristic switch rules differs slightly form regular heuristic rules (the 
latter don't output true or false, but a weight that might vary depending
on the candidate).


  .. _R-PITCHES-ONE-VOICE:

    .. index::
       single: R-PITCHES-ONE-VOICE (function)

 *function* (**R-PITCHES-ONE-VOICE** RULE VOICES INPUT-MODE &OPTIONAL RULE-TYPE WEIGHT)
    <rule> is a logic statement in he form of a function. The output of the 
    function has to be either true or false. If there are more than one 
    input to the function, they will receive consecutive pitches (or 
    consecutive motifs depending on the input-mode). 

    <voices> is the number for the voice (starting at 0) that the rule affects. 
    It is possible to give a list of several voice numbers: The rule will then 
    be applied to every voice in the list (independant of each other).

    <input-mode> determines what type of variables the rule will receive in 
    its inputs:

    - pitches: The rule will receive individual  pitches, one for each input.

    - pitch/nth: As above, but the position of the pitch is also indicated.
      Format: '(pitch nth) Ex. '(60 3).

    - motifs: The rule will receive (consecutive) motifs, one motif for each 
      input. A motif is a collection of pitches that are grouped in 
      a list. Motifs are designed in the domain and cannot be redesigned
      by the engine. Note that a motif may be a single pitch (a list 
      with one MIDI note number) if it is defined as such in the domain.

    - motif/nth: As above, but the position of the pitches is also indicated.
      Format: '((pitch-motif) (nth-list)) Ex. '((60 64) (3 4)).

    - motif/index: As motifs, but the index of the variable is also indicated.
      Format: '((pitch-motif) index) Ex. '((60 64) 2).

    - all-pitches: All pitches in the voice that are assigned at the time the  
      rule is checked are given as a list of MIDI note numbers.  
      The list will thus become longer and longer during the 
      search. The rule can only have ONE input in this mode.

    [Backtracking: This rule will trigger backtracking in its own engine.]


Optional inputs:
By expanding the box it is possible to use the rule as a heuristic switch 
rule. A heuristic switch rule is still using a logic statement (that 
outputs true or false), but the effect of the rule is different: If the rule 
is true, the weight (given in the <weight> input) is passed to the engine. 
If it is false, a weight of 0 will be passed. A candidate that receive a 
high weight will have a higher priority for being picked when the true/false 
rules are checked. A heuristic rule can never fail a candidate, nor can it 
trigger backtracking of the engine. Heuristic rules only sort the 
candidates locally before the strict rules are applied. Depending on the 
context, heuristic rules might have more or less of an effect. 

Heuristic switch rules differs slightly form regular heuristic rules (the 
latter don't output true or false, but a weight that might vary depending
on the candidate).



  .. _R-INDEX-PITCHES-ONE-VOICE:

    .. index::
       single: R-INDEX-PITCHES-ONE-VOICE (function)

 *function* (**R-INDEX-PITCHES-ONE-VOICE** RULE POSITIONS VOICES INPUT-MODE &OPTIONAL RULE-TYPE WEIGHT)
    <rule> is a logic statement in he form of a function. The output of the 
    function has to be either true or false. The function should have as many 
    inputs as there are positions given in the <positions> list.

    <positions> is a list of positions where the logic statement is applied.
    Positions are counted from 0. Every position in this list corresponds to
    an input in the rule. See also input-mode below.

    <voices> is the number for the voice (starting at 0) that the rule affects. 
    It is possible to give a list of several voice numbers: The rule will then 
    be applied to every voice in the list (independant of each other).

    <input-mode> determines what type of variables the rule will receive in 
    its inputs:

    - index-for-cell: The rule will receive motifs as lists of MIDI note 
      numbers The positions given above refer to the index
      number for the motifs in the solution. Each input 
      will receive one corresponding motif.

    - position-for-pitches: The rule will receive individual
      pitches, one for each given position.
      The positions refer to the position
      of the individual duraions in the solution.

    [Backtracking: This rule will trigger backtracking in its own engine.]


Optional inputs:
By expanding the box it is possible to use the rule as a heuristic switch 
rule. A heuristic switch rule is still using a logic statement (that 
outputs true or false), but the effect of the rule is different: If the rule 
is true, the weight (given in the <weight> input) is passed to the engine. 
If it is false, a weight of 0 will be passed. A candidate that receive a 
high weight will have a higher priority for being picked when the true/false 
rules are checked. A heuristic rule can never fail a candidate, nor can it 
trigger backtracking of the engine. Heuristic rules only sort the 
candidates locally before the strict rules are applied. Depending on the 
context, heuristic rules might have more or less of an effect. 

Heuristic switch rules differs slightly form regular heuristic rules (the 
latter don't output true or false, but a weight that might vary depending
on the candidate).


  .. _R-TIME-SIGNATURES:

    .. index::
       single: R-TIME-SIGNATURES (function)

 *function* (**R-TIME-SIGNATURES** RULE INPUT-MODE &OPTIONAL RULE-TYPE WEIGHT)
    <rule> is a logic statement in he form of a function. The output of the 
    function has to be either true or false. If there are more than one 
    input to the function, they will receive consecutive time signatures.

    <input-mode> determines what type of variables the rule will receive in 
    its inputs:

    - timesigns: The rule will receive individual time signatures, one for 
      each input. Ex. '(4 4)

    - all-timesigns: All time signatures in the score that are assigned at the
      time the rule is checked are given as a list of time   
      signatures. The list will thus become longer and longer 
      during the search. The rule can only have ONE input in 
      this mode. Ex. '((4 4) (6 8))

    [Backtracking: This rule will trigger backtracking in its own engine.]


Optional inputs:
By expanding the box it is possible to use the rule as a heuristic switch 
rule. A heuristic switch rule is still using a logic statement (that 
outputs true or false), but the effect of the rule is different: If the rule 
is true, the weight (given in the <weight> input) is passed to the engine. 
If it is false, a weight of 0 will be passed. A candidate that receive a 
high weight will have a higher priority for being picked when the true/false 
rules are checked. A heuristic rule can never fail a candidate, nor can it 
trigger backtracking of the engine. Heuristic rules only sort the 
candidates locally before the strict rules are applied. Depending on the 
context, heuristic rules might have more or less of an effect. 

Heuristic switch rules differs slightly form regular heuristic rules (the 
latter don't output true or false, but a weight that might vary depending
on the candidate).



  .. _R-INDEX-TIME-SIGNATURES:

    .. index::
       single: R-INDEX-TIME-SIGNATURES (function)

 *function* (**R-INDEX-TIME-SIGNATURES** RULE INDEXES &OPTIONAL RULE-TYPE WEIGHT)
    <rule> is a logic statement in he form of a function. The output of the 
    function has to be either true or false. The function should have as many 
    inputs as there are positions given in the <positions> list.

    <indexes> is a list of positions where the logic statement is applied.
    Indexes are counted from 0. Every position in this list corresponds to
    an input in the rule. 


[Backtracking: This rule will trigger backtracking in its own engine.]


Optional inputs:
By expanding the box it is possible to use the rule as a heuristic switch 
rule. A heuristic switch rule is still using a logic statement (that 
outputs true or false), but the effect of the rule is different: If the rule 
is true, the weight (given in the <weight> input) is passed to the engine. 
If it is false, a weight of 0 will be passed. A candidate that receive a 
high weight will have a higher priority for being picked when the true/false 
rules are checked. A heuristic rule can never fail a candidate, nor can it 
trigger backtracking of the engine. Heuristic rules only sort the 
candidates locally before the strict rules are applied. Depending on the 
context, heuristic rules might have more or less of an effect. 

Heuristic switch rules differs slightly form regular heuristic rules (the 
latter don't output true or false, but a weight that might vary depending
on the candidate).


  .. _R-ONLY-M-MOTIFS:

    .. index::
       single: R-ONLY-M-MOTIFS (function)

 *function* (**R-ONLY-M-MOTIFS** VOICES &OPTIONAL RULE-TYPE WEIGHT)
    This rule will force the system to only pick transposable pitch
    motifs (motifs defined as melodic intervals and flagged with the 
    letter m). The first variable in a voice is an exception: this 
    variable always has to be a pitch defined as a MIDI note value.

    <voices> is the number for the voice (starting at 0) that the rule affects. 
    It is possible to give a list of several voice numbers: The rule will then 
    be applied to every voice in the list (independant of each other).

    [Backtracking: This rule will trigger backtracking in its own engine.]


Optional inputs:
By expanding the box it is possible to use the rule as a heuristic switch 
rule. A heuristic switch rule is still using a logic statement (that 
outputs true or false), but the effect of the rule is different: If the rule 
is true, the weight (given in the <weight> input) is passed to the engine. 
If it is false, a weight of 0 will be passed. A candidate that receive a 
high weight will have a higher priority for being picked when the true/false 
rules are checked. A heuristic rule can never fail a candidate, nor can it 
trigger backtracking of the engine. Heuristic rules only sort the 
candidates locally before the strict rules are applied. Depending on the 
context, heuristic rules might have more or less of an effect. 

Heuristic switch rules differs slightly form regular heuristic rules (the 
latter don't output true or false, but a weight that might vary depending
on the candidate).



  .. _R-RHYTHMS-ONE-VOICE-AT-TIMEPOINTS:

    .. index::
       single: R-RHYTHMS-ONE-VOICE-AT-TIMEPOINTS (function)

 *function* (**R-RHYTHMS-ONE-VOICE-AT-TIMEPOINTS** RULE VOICE TIMEPOINTS INPUT-MODE)
    Rule for rhythms that exist at timepoints in one voice.

    <rule> is a logic statement in he form of a function. The output of the 
    function has to be either true or false. .If there are more than one 
    input to the function, they will receive the information for consecutive
    timepoints.

    <voices> is the number for the voice (starting at 0) that the rule affects. 
    It is possible to give a list of several voice numbers: The rule will then 
    be applied to every voice in the list (independant of each other).

    <timepoints> is a list of timepoints (starting from 0) counted from the 
    beginning of the score where the rule will be checked. For example
    the timepoint 15/4 will be 15 quarter notes from the beginning of the 
    score. 

    <input-mode>              

    - motifs-start: The start time for motifs will be compared to the given 
      timepoint. An input receives the as 
      '(offset-to-timepoint (motif)). Offset is the duration 
      between the startingpoint of the motif and given timepoint. 
      Ex. (-1/4 (1/8 -1/8 1/16 1/16))

    - motifs-end:   The end time for motifs will be compared to the given 
      timepoint. An input receives the as 
      '(offset-to-timepoint (motif)). Offset is the duration 
      between the endingpoint of the motif and given timepoint. 
      Ex. (1/8 (1/8 -1/8 1/16 1/16))

    - dur-start:    The start time for durations and rests will be compared to 
      the given timepoint. An input receives the as 
      '(offset-to-timepoint duration). Offset is the duration 
      between the startingpoint of the event and given timepoint. 
      Ex. (-1/16 1/4)



This rule always prefer to backtrack the rhythm engine that it belongs to.


  .. _HR-RHYTHMS-ONE-VOICE:

    .. index::
       single: HR-RHYTHMS-ONE-VOICE (function)

 *function* (**HR-RHYTHMS-ONE-VOICE** RULE VOICES RULETYPE)
          Heuristic rule for durations in one voice.

    Heuristic rules sort the candidates locally according to weights. 
    The true/false rules will test candidates that receive high weights by
    the heuristic rules before other candidates (and in this way give them
    higher priority). A heuristic rule can never fail a candidate, nor 
    can it trigger backtracking of an engine. 

    <rule> is a function that outputs a numerical weight. If there are 
    more than one input to the function, it will receive consecutive 
    pitches or consecutive motifs depending on the input-mode (see below). 

    <voices> is the number for the voice (starting at 0) that the heuristic 
    rule affects. It is possible to give a list of several voice numbers: 
    The rule will then be applied to every voice in the list (independant 
    of each other).

    <input-mode> determines what type of variables the rule will receive in 
    its inputs:

    - durations: The rule will receive individual  pitches, one for each input.

    - dur/time: As above, but the start time of the duration will be indicated.
      Format: '(duration start-time), Ex. '(1/4 9/4)

    - motifs: The rule will receive (consecutive) motifs, one motif for each 
      input. A motif is a collection of durations that are grouped in 
      a list. Motifs are designed in the domain and cannot be 
      redesignedby the engine. Note that a motif may be a single 
      duration (a list with one duration ratio) if it is defined as 
      such in the domain.

    - motif/time: As the previous selection, but with the start time of the 
      first event in the motif added. Format: '(motif start-time)
      Ex. '((1/4 -1/8) 9/8)

    - all-durations: All durations in the voice that are assigned at the time 
      the rule is checked are given as a list of duration ratios.  
      The list will thus become longer and longer during the 
      search. The rule can only have ONE input in this mode.



  .. _HR-INDEX-RHYTHMS-ONE-VOICE:

    .. index::
       single: HR-INDEX-RHYTHMS-ONE-VOICE (function)

 *function* (**HR-INDEX-RHYTHMS-ONE-VOICE** RULE POSITIONS VOICE RULETYPE)
          Heuristic index rule for durations in one voice.

    Heuristic rules sort the candidates locally according to weights. 
    The true/false rules will test candidates that receive high weights by
    the heuristic rules before other candidates (and in this way give them
    higher priority). A heuristic rule can never fail a candidate, nor 
    can it trigger backtracking of an engine. 

    <rule> is a function that outputs a numerical weight. The function 
    should have as many inputs as there are positions given in the 
    <positions> list. 

    <positions> is a list of positions where the heuristic rule is applied.
    Positions are counted from 0. Every position in this list corresponds to
    an input in the rule. See also input-mode below.

    <voices> is the number for the voice (starting at 0) that the heuristic 
    rule affects. It is possible to give a list of several voice numbers: 
    The rule will then be applied to every voice in the list (independant 
    of each other).


<input-mode> determines what type of variables the heuristic rule will
receive in its inputs:

- index-for-cell: The rule will receive motifs as lists of duration 
  ratios. The positions given above refer to the index
  number for the motifs in the solution. Each input 
  will receive one corresponding motif.

- position-for-duration: The rule will receive individual
  durations, one for each given position.
  The positions refer to the position
  of the individual duraions in the solution.
  Rests are included.



  .. _HR-PITCHES-ONE-VOICE:

    .. index::
       single: HR-PITCHES-ONE-VOICE (function)

 *function* (**HR-PITCHES-ONE-VOICE** RULE VOICES INPUT-MODE)
          Heuristic rule for pitches in one voice.

    Heuristic rules sort the candidates locally according to weights. 
    The true/false rules will test candidates that receive high weights by
    the heuristic rules before other candidates (and in this way give them
    higher priority). A heuristic rule can never fail a candidate, nor 
    can it trigger backtracking of an engine. 

    <rule> is a function that outputs a numerical weight. If there are more 
    than one input to the function, it will receive consecutive pitches 
    or consecutive motifs depending on the input-mode (see below). 

    <voices> is the number for the voice (starting at 0) that the heuristic 
    rule affects. It is possible to give a list of several voice numbers: 
    The rule will then be applied to every voice in the list (independant 
    of each other).

    <input-mode> determines what type of variables the rule will receive in 
    its inputs:

    - pitches The rule will receive individual  pitches, one for each input.

    - pitch/nth: As above, but the position of the pitch is also indicated.
      Format: '(pitch nth) Ex. '(60 3).

    - motifs: The rule will receive (consecutive) motifs, one motif for each 
      input. A motif is a collection of pitches that are grouped in 
      a list. Motifs are designed in the domain and cannot be redesigned
      by the engine. Note that a motif may be a single pitch (a list 
      with one MIDI note number) if it is defined as such in the domain.

    - motif/nth: As above, but the position of the pitches is also indicated.
      Format: '((pitch-motif) (nth-list)) Ex. '((60 64) (3 4)).

    - motif/index: As motifs, but the index of the variable is also indicated.
      Format: '((pitch-motif) index) Ex. '((60 64) 2).

    - all-pitches: All pitches in the voice that are assigned at the time the  
      rule is checked are given as a list of MIDI note numbers.  
      The list will thus become longer and longer during the 
      search. The rule can only have ONE input in this mode.



  .. _HR-INDEX-PITCHES-ONE-VOICE:

    .. index::
       single: HR-INDEX-PITCHES-ONE-VOICE (function)

 *function* (**HR-INDEX-PITCHES-ONE-VOICE** RULE POSITIONS VOICE INPUT-MODE)
          Heuristic index rule for pitches in one voice.

    Heuristic rules sort the candidates locally according to weights. 
    The true/false rules will test candidates that receive high weights by
    the heuristic rules before other candidates (and in this way give them
    higher priority). A heuristic rule can never fail a candidate, nor 
    can it trigger backtracking of an engine. 

    <rule> is a function that outputs a numerical weight. The function 
    should have as many inputs as there are positions given in the 
    <positions> list. 

    <positions> is a list of positions where the heuristic rule is applied.
    Positions are counted from 0. Every position in this list corresponds to
    an input in the rule. See also input-mode below.

    <voices> is the number for the voice (starting at 0) that the heuristic 
    rule affects. It is possible to give a list of several voice numbers: 
    The rule will then be applied to every voice in the list (independant 
    of each other).

    <input-mode> determines what type of variables the rule will receive in 
    its inputs:

    - index-for-cell: The rule will receive motifs as lists of MIDI note 
      numbers The positions given above refer to the index
      number for the motifs in the solution. Each input 
      will receive one corresponding motif.

    - position-for-pitches: The rule will receive individual
      pitches, one for each given position.
      The positions refer to the position
      of the individual duraions in the solution.



  .. _HR-TIME-SIGNATURES:

    .. index::
       single: HR-TIME-SIGNATURES (function)

 *function* (**HR-TIME-SIGNATURES** RULE INPUT-MODE)
          Heuristic rules sort the candidates locally according to weights. 
    The true/false rules will test candidates that receive high weights by
    the heuristic rules before other candidates (and in this way give them
    higher priority). A heuristic rule can never fail a candidate, nor 
    can it trigger backtracking of an engine. 

    <rule> is a function that outputs a numerical weight. If there are 
    more than one input to the function, they will receive consecutive 
    time signatures.

    <input-mode> determines what type of variables the rule will receive in 
    its inputs:

    - timesigns: The rule will receive individual time signatures, one for 
      each input. Ex. '(4 4)

    - all-timesigns: All time signatures in the score that are assigned at the
      time the rule is checked are given as a list of time   
      signatures. The list will thus become longer and longer 
      during the search. The rule can only have ONE input in 
      this mode. Ex. '((4 4) (6 8))




  .. _HR-INDEX-TIME-SIGNATURES:

    .. index::
       single: HR-INDEX-TIME-SIGNATURES (function)

 *function* (**HR-INDEX-TIME-SIGNATURES** RULE INDEXES)
          Heuristic rules sort the candidates locally according to weights. 
    The true/false rules will test candidates that receive high weights by
    the heuristic rules before other candidates (and in this way give them
    higher priority). A heuristic rule can never fail a candidate, nor 
    can it trigger backtracking of an engine. 

    <rule> is a function that outputs a numerical weight. The function 
    should have as many inputs as there are positions given in the 
    <indexes> list.

    <indexes> is a list of positions where the logic statement is applied.
    Indexes are counted from 0. Every position in this list corresponds to
    an input in the rule. See also input-mode below.




  .. _R-PMC-ONE-VOICE:

    .. index::
       single: R-PMC-ONE-VOICE (function)

 *function* (**R-PMC-ONE-VOICE** PMCRULES0 RULETYPE0 VOICE0 &OPTIONAL PMCRULES1 RULETYPE1 VOICE1 PMCRULES2 RULETYPE2 VOICE2 PMCRULES3 RULETYPE3 VOICE3 PMCRULES4 RULETYPE4 VOICE4 PMCRULES5 RULETYPE5 VOICE5 PMCRULES6 RULETYPE6 VOICE6 PMCRULES7 RULETYPE7 VOICE7 PMCRULES8 RULETYPE8 VOICE8 PMCRULES9 RULETYPE9 VOICE9)
    This box makes it possible to use PMC formated rules with the Poly-engine. The box expects a list of rules (for
    example from a text box). The following PMC related variables and functions are supported:
    L, RL, LEN, (cur-index)

    Both wildcard rules and index rules are possible to use. Wildcard rules are expected to use variables 
    in order.


  .. _R-JBS-ONE-VOICE:

    .. index::
       single: R-JBS-ONE-VOICE (function)

 *function* (**R-JBS-ONE-VOICE** JBSRULE0 RULETYPE0 VOICE0 &OPTIONAL JBSRULE1 RULETYPE1 VOICE1 JBSRULE2 RULETYPE2 VOICE2 JBSRULE3 RULETYPE3 VOICE3 JBSRULE4 RULETYPE4 VOICE4 JBSRULE5 RULETYPE5 VOICE5 JBSRULE6 RULETYPE6 VOICE6 JBSRULE7 RULETYPE7 VOICE7 JBSRULE8 RULETYPE8 VOICE8 JBSRULE9 RULETYPE9 VOICE9)
          This box makes it possible to use rules from the JBS-constraint library. 
    The box can handle both true/false rules and heuristic rules.

    Rules that use the (cur-slen) function are not supported (it is possible 
    to use these rules by letting them pass the set-end box).

    The voice input can be a list with all voices that the rule should affect.

    Score-PMC-rules are NOT supported. 



  .. _SET-END:

    .. index::
       single: SET-END (function)

 *function* (**SET-END** RULE END-POINT)
    This box will set the endpoint for a jbs or a pmc rule. The rule should
    pass through this box before going into the r-jbs-one-voice box (or the
    r-pmc-one-voice box). The end point is the position (i.e. not the index) for 
    the last value in a voice where the rule is checked. It also replaces 
    the '(cur-slen) expression by the end point.

    Note that the first value has the position 1 (this is compatible with
    how index numbers are counted in the PMC engine).

Rules for One Voice
~~~~~~~~~~~~~~~~~~~

Rules for Two Voices
~~~~~~~~~~~~~~~~~~~~

Rules for Two or More Voices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Other Functions
---------------

Special Domain Declarations, Debugging and More
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  .. _METRIC-DOMAIN:

    .. index::
       single: METRIC-DOMAIN (function)

 *function* (**METRIC-DOMAIN** TIMESIGN1 TUPLETS1 ALT-BEATLENGTH1 &OPTIONAL TIMESIGN2 TUPLETS2 ALT-BEATLENGTH2 TIMESIGN3 TUPLETS3 ALT-BEATLENGTH3 TIMESIGN4 TUPLETS4 ALT-BEATLENGTH4 TIMESIGN5 TUPLETS5 ALT-BEATLENGTH5 TIMESIGN6 TUPLETS6 ALT-BEATLENGTH6 TIMESIGN7 TUPLETS7 ALT-BEATLENGTH7 TIMESIGN8 TUPLETS8 ALT-BEATLENGTH8)
    This box sets the metric domain in more detail than just a list of possible time signatures.

    <tuplets> is a list of allowed subdivisions of the beat. This setting only has an effect if 
    using the rule r-metric-hierarchy.

    <alt-beatlength> allows the user to define another beat length than the time 
    signature indicates. This will affect rules that consrain events located on
    beats:

    - nil:  If this input is nil, the default beat length for a time signature 
      will be used (i.e. the time signature '(4 4) will have the beat length
      1/4, the time signature '(6 8) will have the beat length 1/8, etc.

    - [a fraction]: If this input is a fraction, it will be used as the beat
      length. For example, if the time signature is '(6 8), the fraction
      3/8 will give replace the default beat length 1/8. The subdivision of 
      beats (the tuplets input) will relate to the alternative beat length.

    - [a list]:  If this input is a list, it will define an arbitrary beat
       division of the measure. For example, if the time signature is
      '(9 8), the list '(3/8 2/8 2/8 2/8) will distribute the beats
      accordingly. NOTE: the sum of the beats have to add up to the length 
      of a measure. The subdivision of beats (the tuplets input) will
      relate to the default beat length.



  .. _R-PREDEFINE-METER:

    .. index::
       single: R-PREDEFINE-METER (function)

 *function* (**R-PREDEFINE-METER** TIMESIG-LIST)
    This rule predefines the time signature to follow a given sequence.
    WARNING: This rule will preset the sequence of time signature and 
    will not allow the system to backtrack them.

    It the given list of time signatures is shorted than what is needed 
    in the solution, the remaining time signatures will be picked
    randomly.



  .. _STOP-RULE-TIME:

    .. index::
       single: STOP-RULE-TIME (function)

 *function* (**STOP-RULE-TIME** VOICES STOPTIME INPUT-MODE)
    This rule will not affect the choice of musical parameters (it will always be true), but it will stop the search when a time point has been reached. The solution found when the time point is reached will be returned as a valid solution.

    The rule compares the START TIME of motifs to the stoptime (i.e. the end time or the time point for durations inside motifs of a motif is not checked). The stop will happen when a duration reaches the stop time.

    <voices> is one or a list of voices that will be checked.

    <stoptime> is a timepoint in the score, counting from 0, where the search will stop (ex. the time point 5/2 is 2 whole notes + 1 half note into the score). The stoptime has to be reached in all given voices. Note that the rule ignors the pitch information.

    <input-mode>

    - OR: The search will stop when one of the voices in the given list reached the stop time. The metric structure will be ignored.

    - AND: The search will stop when all the voices in the given list reached the stop time. The metric structure will be ignored.

    - meter: The start time for the measures will determine the stop.


Note that if the system has not assigned a meter for durations, they will not be displayed in the score.




  .. _STOP-RULE-INDEX:

    .. index::
       single: STOP-RULE-INDEX (function)

 *function* (**STOP-RULE-INDEX** VOICES STOPINDEX INPUT-MODE PARAMETERS)
    This rule will not affect the choice of musical parameters (it will always be true), but it will stop the search when an index has been reached. The solution found when the index is reached will be returned as a valid solution.

    <voices> is one or a list of voices that will be checked.

    <stopindex> is an index in the score, counting from 0, where the search will stop.

    <input-mode>

    - OR: The search will stop when one of the voices in the given list reached the stop time. The metric structure will be ignored.




TODO: function ``CLUSTERdebug`` named differently?

  .. _PREFERENCES:

    .. index::
       single: PREFERENCES (function)

 *function* (**PREFERENCES** BACKJUMP? MAX-NR-OF-LOOPS BKTR-RP1V BKTR-RR2V BKTR-RH2V BKTR-RMH2V BKTR-DM1V BKTR-NM1V BKTR-MD1V BKTR-MN1V BKTR-PPNV BKTR-LENV)
          By evaluating this box you may change some default settings of the 
    system. The box should not be connected to other boxes. Note that you 
    need to evaluate this box every time you restart PWGL or after you 
    change a setting to change the preferences.

    <backjump?>     Backjumping speeds up backtracking by jumping 
    directly to the variable that caused a failed ruletest instead of 
    step-by-step backtracking. The speed difference vary from no 
    difference to a huge difference. The way backjumping is used in this 
    system, it should not cause the system to miss possible solutions. It 
    is strongly recommended to keep backjumping on.

    <max-nr-of-loops> is the maximum search loops the engine will do before stopping. 
    ---

    The following variables sets what engine a failed rule prefers to
    backtrack. If the prefered engine cannot be backtracked, the system
    will make another choice based on lower priorities. Note that if
    more than one rule fails, the choice will be based on the most
    frequently proposed engine to backtrack. 

    The default settings can be found by opening a new preference box.

    <bktr-rp1v>  r-rhyth-pitch-one-vocie

    - self (default): backtrack the engine (rhythm or pitch) where the failed variable was found.

    - other: backtrack the engine (rhythm or pitch) that is associated with the enginewhere the failed variable was found.

    <bktr-rr2v> r-rhythm-rhythm

    - self: backtrack the engine (voice 1 or 2) where the failed varialbe was found.

    - other (default): backtrack the engine (voice 1 or 2) that is associated with the engine where the failed variable was found.

    <bktr-rh2v> r-rhythm-hierarchy

    - self: backtrack the engine (voice 1 or 2) where the failed variable was found.

    - other (default): backtrack the engine (voice 1 or 2) that is associated with the engine where the failed variable was found.

    <bktr-rmh2v> r-metric-hierarchy

    - rhythm (default): backtrack the rhythm engine

    - meter: backtrack the metric engine.

    <bktr-dm1v> r-note-meter if pitch information is NOT asked for

    - rhythm (default): backtrack the rhythm engine

    - meter: backtrack the metric engine.

    <bktr-nm1v> r-note-meter if pitch information is asked for

    - self (default): backtrack the engine (rhythm, pitch or meter) where the failed variable was found.

    - rhythm/pitch: backtrack the engine (rhythm or pitch) that is associated with the engine where the failed variable was found. The metric engine always prefer to backtrack the rhythm engine.

    - pitch/rhythm: backtrack the engine (rhythm or pitch) that is associated with the engine where the failed variable was found. The metric engine always prefer to backtrack the pitch engine.

    <bktr-md1v> r-meter-note if pitch information is NOT asked for

    - rhythm (default): backtrack the rhythm engine

    - meter: backtrack the metric engine.

    <bktr-mn1v> r-meter-note if pitch information is asked for

    - self (default): backtrack the engine (rhythm, pitch or meter) where the failed variable was found.

    - rhythm/pitch: backtrack the engine (rhythm or pitch) that is associated with the engine where the failed variable was found. The metric engine always prefer to backtrack the rhythm engine.

    - pitch/rhythm: backtrack the engine (rhythm or pitch) that is associated with the engine where the failed variable was found. The metric engine always prefer to backtrack the pitch engine.

    <bktr-ppnv> r-pitch-pitch

    - next-pitch (default): backtrack the pitch engine after the engine where the failed variable was found (the order is defined by the voice input).

    - next-rhythm: backtrack the pitch engine after the engine where the failed variable was found (the order is defined by the voice input).

    - current-pitch: if the failed variable is in a pitch engine, backtrack the same engine. If it is in a rhythm engine, backtrack the associated pitch engine.

    - current-rhythm: if the failed variable is in a rhythm engine, backtrack the same engine. If it is in a pitch engine, backtrack the associated rhythm engine.

    <bktr-leNv> r-list-all-events

    - next:  backtrack the engine after the engine where the failed variable was found (the order is defined by the voice input).

    - self:  backtrack the engine where the failed variable was found.

Utilities
~~~~~~~~~

Here goes on the general text. Here goes on the general text. Here
goes on the general text. Here goes on the general text.
