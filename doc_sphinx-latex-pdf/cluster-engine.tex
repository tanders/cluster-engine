%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{cluster-engine Documentation}
\date{Sep 21, 2017}
\release{0.158}
\author{Örjan Sandred}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Overview}
\label{\detokenize{readme::doc}}\label{\detokenize{readme:cluster-engine-documentation}}\label{\detokenize{readme:overview}}\begin{quote}
\begin{quote}\begin{description}
\item[{Author}] \leavevmode
torsten

\end{description}\end{quote}
\end{quote}

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{readme:id7}}{\hyperref[\detokenize{readme:overview}]{\sphinxcrossref{Overview}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{readme:id8}}{\hyperref[\detokenize{readme:introduction}]{\sphinxcrossref{Introduction}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{readme:id9}}{\hyperref[\detokenize{readme:references}]{\sphinxcrossref{References}}}

\end{itemize}

\item {} 
\phantomsection\label{\detokenize{readme:id10}}{\hyperref[\detokenize{readme:installation}]{\sphinxcrossref{Installation}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{readme:id11}}{\hyperref[\detokenize{readme:id1}]{\sphinxcrossref{PWGL}}}

\item {} 
\phantomsection\label{\detokenize{readme:id12}}{\hyperref[\detokenize{readme:common-lisp}]{\sphinxcrossref{Common Lisp}}}

\item {} 
\phantomsection\label{\detokenize{readme:id13}}{\hyperref[\detokenize{readme:updating-your-software}]{\sphinxcrossref{Updating your software}}}

\end{itemize}

\item {} 
\phantomsection\label{\detokenize{readme:id14}}{\hyperref[\detokenize{readme:usage}]{\sphinxcrossref{Usage}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{readme:id15}}{\hyperref[\detokenize{readme:id3}]{\sphinxcrossref{PWGL}}}

\item {} 
\phantomsection\label{\detokenize{readme:id16}}{\hyperref[\detokenize{readme:id4}]{\sphinxcrossref{Common Lisp}}}

\item {} 
\phantomsection\label{\detokenize{readme:id17}}{\hyperref[\detokenize{readme:cluster-rules}]{\sphinxcrossref{Cluster Rules}}}

\end{itemize}

\end{itemize}

\end{itemize}
\end{sphinxShadowBox}


\section{Introduction}
\label{\detokenize{readme:introduction}}
Cluster Engine is a constraint solver for solving polyphonic constraint satisfaction problems where both the pitch and the rhythmic structure can be restricted by an arbitrary number of constraints (rules), and the solver then searches for a solution that is consistent with all constraints. This library supports user-defined rules, and highly flexible ways to control which aspects of the resulting score are controlled by certain rules. For example, you can independently control with compositional rules the melody and harmony of the music you generate.

Cluster Engine is developed by Örjan Sandred . It is the successor of PWMC (Sandred, 2010). Cluster Engine was originally developed as a library for the free composition environment \sphinxhref{http://www2.siba.fi/pwgl}{PWGL}.

The present version still runs in PWGL, but also on plain Common Lisp in order to make it useable within \sphinxhref{http://opusmodus.com}{Opusmodus} and \textendash{} via a \sphinxhref{http://www.sbcl.org}{SBCL} interface \textendash{} in the music and media programming environment \sphinxhref{https://cycling74.com/products/max}{Max} (Vincenot, 2017).

Cluster Engine has been successfully tested on PWGL (based on Lispworks), SBCL and Opusmodus (\sphinxhref{http://ccl.clozure.com}{Clozure CL}).


\subsection{References}
\label{\detokenize{readme:references}}
Sandred, Ö. (2010) PWMC, a Constraint-Solving System for Generating Music Scores. \sphinxstyleemphasis{Computer Music Journal}. 34(2), 8\textendash{}24.

Vincenot, J. (2017) LISP in Max: Exploratory Computer-Aided Composition in Real-Time. \sphinxstyleemphasis{ICMC 2017}.


\section{Installation}
\label{\detokenize{readme:installation}}

\subsection{PWGL}
\label{\detokenize{readme:id1}}
These instructions explain how to install Cluster Engine for PWGL. First, download the library with the download link at \sphinxurl{http://github.com/tanders/cluster-engine} and unzip the folder. Then, make sure the folder is named \sphinxcode{cluster-engine} (remove the \sphinxcode{master} part of the folder name). Finally, move this folder inside the PWGL user library folder (\sphinxcode{\textasciitilde{}/PWGL-User/User-library/}).


\subsection{Common Lisp}
\label{\detokenize{readme:common-lisp}}
This section explain how to install Cluster Engine as a plain Common Lisp library (e.g., to be used by Opusmodus). We are using git for the installation. Even though this is a bit more involved at first, it allows for convenient updates later, and you can even contribute to the development.

Install \sphinxhref{https://git-scm.com}{git} (if you have not done already). Also, you should register at \sphinxhref{https://github.com}{GitHub}.

Download the present software with git into a directory where \sphinxhref{https://common-lisp.net/project/asdf/}{ASDF} can find the software, e.g., \sphinxhref{https://common-lisp.net/project/asdf/asdf/Quick-start-summary.html\#Quick-start-summary}{\textasciitilde{}/common-lisp/}. For example, on UNIX incl. OS X you can enter the following commands at the command line (after you created the directory \sphinxcode{\textasciitilde{}/common-lisp/}). Note that \sphinxcode{\$} is the terminal prompt here, you do not need to enter that :)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd \PYGZti{}/common\PYGZhy{}lisp
\PYGZdl{} git clone https://github.com/tanders/cluster\PYGZhy{}engine.git
\end{sphinxVerbatim}

You will be asked for your GitHub username and password.


\subsection{Updating your software}
\label{\detokenize{readme:updating-your-software}}
If there are \sphinxhref{https://github.com/tanders/cluster-engine/commits/master}{changes}, you can update your software later at the terminal in the following way.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd \PYGZti{}/common\PYGZhy{}lisp/cluster\PYGZhy{}engine
\PYGZdl{} git pull
\end{sphinxVerbatim}


\section{Usage}
\label{\detokenize{readme:usage}}

\subsection{PWGL}
\label{\detokenize{readme:id3}}
If you use Cluster Engine in PWGL, you load the library in PWGL with File \textgreater{} Load Library…

The library comes with a tutorial, which you find under Help \textgreater{} PWGL Tutorial… In the tutorial browser that opens then move to Library Tutorials \textgreater{} cluster-engine. The tutorial consists of a collection of live patches with comments and documentation slides.


\subsection{Common Lisp}
\label{\detokenize{readme:id4}}
Cluster Engine is an \sphinxhref{https://common-lisp.net/project/asdf/}{ASDF} system (ASDF is the de facto standard for building Common Lisp software), and you can load it into your Lisp compiler as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{require} \PYG{p}{:}\PYG{n}{cluster}\PYG{o}{\PYGZhy{}}\PYG{n}{engine}\PYG{p}{)}
\end{sphinxVerbatim}

The library should now be loaded, and you can solve musical constraint satisfaction problems. The first example below is an “empty” problem without any constraints yet. The function \sphinxcode{clusterengine} is the constraint solver. Its first three arguments specify the number of variables (quasi notes) per voice (\sphinxcode{10} in this example), whether or not to randomise the solution (\sphinxcode{T}) and whether to use additional debugging features (\sphinxcode{nil}).  After a list of constraints (empty in this first example) the function expects specifications for various domains. These specifications support a mini language for flexibility, the specifications below are very simple. Only a single time signature is allowed (all bars are in 3/4 time); the single voice can consist of quarter notes and eighth notes; and possible pitches are middle C and C\# (MIDI note numbers 60 and 61).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{ce}\PYG{p}{:}\PYG{p}{:}\PYG{n}{clusterengine}
 \PYG{l+m+mi}{10} \PYG{n}{t} \PYG{n}{nil}           \PYG{p}{;} \PYG{n}{settings}
 \PYG{n}{nil}                \PYG{p}{;} \PYG{n}{no} \PYG{n}{constraints}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{((3 4))           ; metric domain}
 \PYG{p}{;}\PYG{p}{;} \PYG{n}{domain} \PYG{n}{of} \PYG{n}{rhythmic} \PYG{n}{values} \PYG{o+ow}{and} \PYG{n}{pitches} \PYG{k}{for} \PYG{n}{one} \PYG{n}{voice}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{(((1/4) (1/8))}
   \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{60}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{61}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxcode{clusterengine} outputs a declaration of the sequences of time signatures, rhythmic values and pitches for each voice.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{p}{;} \PYG{n}{rhythmic} \PYG{n}{values} \PYG{n}{of} \PYG{n}{voice} \PYG{l+m+mi}{1}
 \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{8} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{8} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{8} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{8} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{8} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{8} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{8} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{8}\PYG{p}{)}
 \PYG{p}{;} \PYG{n}{pitches}
 \PYG{p}{(}\PYG{l+m+mi}{60} \PYG{l+m+mi}{61} \PYG{l+m+mi}{60} \PYG{l+m+mi}{61} \PYG{l+m+mi}{61} \PYG{l+m+mi}{60} \PYG{l+m+mi}{60} \PYG{l+m+mi}{60} \PYG{l+m+mi}{60} \PYG{l+m+mi}{61}\PYG{p}{)}
 \PYG{p}{;} \PYG{n}{time} \PYG{n}{signatures}
 \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{3} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{3} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{3} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

The output is automatically translated into a notated score in PWGL, and can be translated into an OpusModus score with the function \sphinxcode{cluster-engine-score}, which in turn can be translated into a notated score with \sphinxcode{preview-score} \textendash{} both functions provided by the library \sphinxhref{https://github.com/tanders/tot}{tot}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{p}{:}\PYG{o}{\textbar{}}\PYG{l+m+mi}{1}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{p}{(}\PYG{n}{q} \PYG{n}{c4} \PYG{n}{e} \PYG{n}{cs4} \PYG{n}{c4} \PYG{n}{cs4} \PYG{n}{cs4} \PYG{n}{tie}\PYG{p}{)} \PYG{p}{(}\PYG{n}{e} \PYG{n}{cs4} \PYG{n}{c4} \PYG{n}{c4} \PYG{n}{c4} \PYG{n}{c4} \PYG{n}{cs4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

The above constraint problem does not include any musical rules. Without a detailed discussion, in the following a polyphonic example with a few rules is shown (example 8a translated from the PWGL tutorial into plain Common Lisp). Here, the first rule forces both voices to create 12-tone rows. Rule 2 constrains all harmonic intervals between both voices to consonant intervals or 3, 4, 7, 8 or 9 semitones. Finally, the last rule forbids any voice crossings. A possible result is shown below the code.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{ce}\PYG{p}{:}\PYG{p}{:}\PYG{n}{clusterengine}
 \PYG{l+m+mi}{12} \PYG{n}{t} \PYG{n}{nil}
 \PYG{p}{(}\PYG{n}{append}
  \PYG{p}{;}\PYG{p}{;} \PYG{n}{rule} \PYG{l+m+mi}{1}
  \PYG{p}{(}\PYG{n}{ce}\PYG{p}{:}\PYG{p}{:}\PYG{n}{r}\PYG{o}{\PYGZhy{}}\PYG{n}{pitches}\PYG{o}{\PYGZhy{}}\PYG{n}{one}\PYG{o}{\PYGZhy{}}\PYG{n}{voice} \PYG{c}{\PYGZsh{}\PYGZsq{}(lambda (x)}
                           \PYG{p}{(}\PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{member} \PYG{p}{(}\PYG{n}{mod} \PYG{p}{(}\PYG{n}{car} \PYG{p}{(}\PYG{n}{last} \PYG{n}{x}\PYG{p}{)}\PYG{p}{)} \PYG{l+m+mi}{12}\PYG{p}{)}
                                        \PYG{p}{(}\PYG{n}{mapcar} \PYG{c}{\PYGZsh{}\PYGZsq{}(lambda (a) (mod a 12)) (butlast x)))))}
                       \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{(0 1) :all\PYGZhy{}pitches)}
  \PYG{p}{;}\PYG{p}{;} \PYG{n}{rule} \PYG{l+m+mi}{2}
  \PYG{p}{(}\PYG{n}{ce}\PYG{p}{:}\PYG{p}{:}\PYG{n}{r}\PYG{o}{\PYGZhy{}}\PYG{n}{pitch}\PYG{o}{\PYGZhy{}}\PYG{n}{pitch} \PYG{c}{\PYGZsh{}\PYGZsq{}(lambda (x)}
                     \PYG{p}{(}\PYG{n}{member} \PYG{p}{(}\PYG{n}{mod} \PYG{p}{(}\PYG{n}{ce}\PYG{p}{:}\PYG{p}{:}\PYG{n}{apply}\PYG{o}{\PYGZhy{}}\PYG{n}{minus} \PYG{n}{x}\PYG{p}{)} \PYG{l+m+mi}{12}\PYG{p}{)} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{(3 4 7 8 9)))}
                 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{(0 1) }\PYG{l+s}{\PYGZsq{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{:}\PYG{n+nb}{all} \PYG{p}{:}\PYG{n}{no\PYGZus{}grace} \PYG{p}{:}\PYG{n}{pitch}\PYG{p}{)}
  \PYG{p}{;}\PYG{p}{;} \PYG{n}{rule} \PYG{l+m+mi}{3}
  \PYG{p}{(}\PYG{n}{ce}\PYG{p}{:}\PYG{p}{:}\PYG{n}{R}\PYG{o}{\PYGZhy{}}\PYG{n}{pitch}\PYG{o}{\PYGZhy{}}\PYG{n}{pitch} \PYG{c}{\PYGZsh{}\PYGZsq{}(lambda (x) (\PYGZgt{}= (first x) (second x)) )}
                 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{(0 1) }\PYG{l+s}{\PYGZsq{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{:}\PYG{n+nb}{all} \PYG{p}{:}\PYG{n}{no\PYGZus{}grace} \PYG{p}{:}\PYG{n}{pitch}\PYG{p}{)}\PYG{p}{)}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{((4 4))}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{(;; domains of rhythmic values and pitches of voice 1}
   \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{60}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{61}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{62}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{63}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{65}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{66}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{67}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{68}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{69}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{71}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{72}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{73}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{74}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{75}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{76}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{77}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{78}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{79}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{;}\PYG{p}{;} \PYG{n}{domains} \PYG{n}{of} \PYG{n}{rhythmic} \PYG{n}{values} \PYG{o+ow}{and} \PYG{n}{pitches} \PYG{n}{of} \PYG{n}{voice} \PYG{l+m+mi}{2}
   \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{60}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{61}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{62}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{63}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{65}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{66}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{67}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{68}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{69}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{71}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{72}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{73}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{74}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{75}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{76}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{77}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{78}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{79}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{polyphonic-solution}.jpg}

For further information refer to the PWGL tutorial for now. Pretty much all PWGL boxes have their equivalent Common Lisp function/macro with the same arguments. An exception is the function \sphinxcode{clusterengine} itself, where domains of rhythmic values and pitches are defined in Common Lisp as shown above.


\subsection{Cluster Rules}
\label{\detokenize{readme:cluster-rules}}
The Common Lisp library \sphinxhref{https://github.com/tanders/cluster-rules}{Cluster Rules} extends Cluster Engine by a collection of predefined musical constraints and that way makes it more easy to use. The equivalent PWGL library is \sphinxhref{https://github.com/tanders/pwgl-cluster-rules}{PWGL Cluster Rules}.


\chapter{TODO Title}
\label{\detokenize{API::doc}}\label{\detokenize{API:todo-title}}\begin{quote}
\begin{quote}\begin{description}
\item[{Author}] \leavevmode
torsten

\end{description}\end{quote}
\end{quote}


\section{API}
\label{\detokenize{API:api}}
Extracting docs again :)

\index{RULES-\textgreater{}CLUSTER (function)}\begin{description}
\item[{\sphinxstyleemphasis{function} (\sphinxstylestrong{RULES-\textgreater{}CLUSTER} \&REST RULES)}] \leavevmode
Use this box to collect all rules before inputting them to the Cluster engine. It is possible to input the output of this box to a second Rules-\textgreater{}Cluster box (to help organizing your rules in groups).

\end{description}

\index{CLUSTERENGINE (function)}\begin{description}
\item[{\sphinxstyleemphasis{function} (\sphinxstylestrong{CLUSTERENGINE} NO-OF-VARIABLES RND? DEBUG? RULES METRIC-DOMAIN LIST-OF-DOMAINS)}] \leavevmode
The Cluster Engine - the main function of this library.

Pitch domains cannot exist without at least one duration in the rhythm domain. Domains with only one value will not use up any time in the search process.

See the PWGL tutorials of this library for a detailed discussion of this function.

\end{description}

\index{R-RHYTHMS-ONE-VOICE (function)}\begin{description}
\item[{\sphinxstyleemphasis{function} (\sphinxstylestrong{R-RHYTHMS-ONE-VOICE} RULE VOICES INPUT-MODE \&OPTIONAL RULE-TYPE WEIGHT)}] \leavevmode\begin{quote}\begin{description}
\item[{RULE}] \leavevmode
is a logic statement in he form of a function. The output of the function has to be either true or false. If there are more than one input to the function, they will receive consecutive durations (or consecutive motifs depending on the input-mode).

\item[{VOICES}] \leavevmode
is the number for the voice (starting at 0) that the rule affects. It is possible to give a list of several voice numbers: The rule will then be applied to every voice in the list (independant of each other).

\item[{INPUT-MODE}] \leavevmode
determines what type of variables the rule will receive in its inputs:

\end{description}\end{quote}
\begin{itemize}
\item {} 
\sphinxcode{:durations} The rule will receive individual durations, one for each input.

\item {} 
\sphinxcode{:dur/time} As above, but the start-time of the duration will be indicated.
Format: ‘(duration start-time), Ex. ‘(1/4 9/4)

\item {} 
\sphinxcode{:motifs} The rule will receive motifs, one (consecutive) motif for each
input. A motif is a collection of durations that are grouped in
a list. Motifs are designed in the domain and cannot be
redesignedby the engine. Note that a motif may be a single
duration (a list with one duration-ratio) if it is defined as
such in the domain.

\item {} 
\sphinxcode{:motif/time} As the previous selection, but with the start-time of the first event in the motif added. Format: ‘(motif start-time)
Ex. ‘((1/4 -1/8) 9/8)

\item {} 
\sphinxcode{:all-durations} All durations in the voice that are assigned at the time the rule is checked are given as a list of duration ratios. The list will thus become longer and longer during the search. The rule can only have ONE input in this mode.

\end{itemize}

\sphinxstylestrong{Optional inputs}

By expanding the box it is possible to use the rule as a heuristic switch rule. A heuristic switch rule is still using a logic statement (that outputs true or false), but the effect of the rule is different: If the rule is true, the weight (given in the \textless{}weight\textgreater{} input) is passed to the engine. If it is false, a weight of 0 will be passed. A candidate that receive a high weight will have a higher priority for being picked when the true/false rules are checked. A heuristic rule can never fail a candidate, nor can it trigger backtracking of the engine. Heuristic rules only sort the candidates locally before the strict rules are applied. Depending on the context, heuristic rules might have more or less of an effect.

Heuristic switch rules differs slightly form regular heuristic rules (the latter don’t output true or false, but a weight that might vary dependingon the candidate).

{[}Backtracking: This rule will trigger backtracking in its own engine.{]}

\end{description}

Here goes the general text on.


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{search}

\item {} 
\DUrole{xref,std,std-ref}{genindex}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}